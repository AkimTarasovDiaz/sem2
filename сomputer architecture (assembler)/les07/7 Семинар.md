## Упражнения на представление чисел с конечной точностью
``` c++
int x = ...
if ((x > 0) || (x - 1 < 0))
```
- Неверно при переполнении, когда  x очень маленький и при вычитании единицы будет положительное число.
---

```c++
int x = ...;
if (((x & 7) != 7) || (x << 29 < 0))
```
- Семь кодируется как `111`. `x & 7` у нас сохранит три наименьших разряда, а первые символы числа обращаются в нуль. Следовательно `x` должен иметь три единички в младших битах, чтобы первое условие было ложно.
- Второе условие - сдвиг всех единиц, тогда три единички в младших разрядах станут в старших.
- Условие всегда **Верно**
---

```cpp
int x = ...;
if ( x*x >= 0 )
```
-  При переполнении условие будет **ложно**.

```c++
#include <numeric>
#include <limits>

std::numeric.limits<int>::max();
```
- Максимальное целое число, которое может быть представен через `int`. Далее можем взять корень от этого числа, и получится максимальное число, которое можно умножить на себя и не поймать переполнение.
---

```cpp
x < 0 || -x <= 0

x > 0 || -x >= 0
```
- Два условия. 
- Отрицательных чисел в `int` больше, чем положительных. Возьмем число из отрицательных(минимальное), для которого нет числа по модулю. 
- В итоге первое условие - всегда истина. Второе - Ложь при наименьшем `x`, отрицая которое мы получим его же.
---

```cpp
int x = ...;
int y = ...;

unsigned ux = x;
unsigned uy = y;
```
- Ошибки не будет, но `Warning`, связанный с `unsigned`, мы получим.
- Если Числа положительные, то все ок, а если возьмем отрицательные числа, то вместо них получим ОЧЕНЬ БОЛЬШОЕ ЧИСЛО, тк компилятор не меняет состояние битов при переходе от `signed` к `unsigned`.  Тогда единица на разряде минуса даст просто ОГРОМНОЕ число.
```cpp

x + y == uy + ux
```
- При сравнении будет приведение типов, и обе части условия будут приведены к `unsigned`. Тогда обе стороны равенства дадут нам равные значение, тогда условие всегда  **Верно** 
---
```cpp
int x = ...;
int y = ...;

unsigned ux = x;
unsigned uy = y;

x * ~y + uy * ux == -x 
```
-  Выражение `~y` - побитовое отрицание. `~y = -y + 1` 
- Выражение можно разложить следующим образом:
  $-x*y - x + uy*ux = -x$
- Тогда у нас `-x` сократятся и останестя выражение из примера выше. 
- Выражение всегда Истина
--- 

# Регистры общего назначения

| Регистр | 31    | 16    | 0     | Предназначение регистра    | Соглашения о изменении переменных при вызове функции |
| ------- | ----- | ----- | ----- | -------------------------- | ---------------------------------------------------- |
| %rax    | %eax  | %ax   | %al   | Возвращаемое значение      | **Caller saved**                                     |
| %rbx    | %ebx  | %bx   | %bl   |                            | *Callee saved*                                       |
| %rcx    | %ecx  | %cx   | %cl   | Четвертый аргумент         | **Caller saved**                                     |
| %rdx    | %edx  | %dx   | %dl   | Третий аргумент            | **Caller saved**                                     |
| %rsi    | %esi  | %si   | %sil  | Первый аргумент            | **Caller saved**                                     |
| %rdi    | %edi  | %di   | %dil  | Первый аргумент            | **Caller saved**                                     |
| %rbp    | %ebp  | %bp   | %bpl  |                            | *Callee saved*                                       |
| %rsp    | %esp  | %sp   | %spl  | Указатель на вершину стека | *Callee saved*                                       |
| %r8     | %r8d  | %r8w  | %r8b  | Пятый аргумент             | **Caller saved**                                     |
| %r9     | %r9d  | %r9w  | %r9b  | Шестой аргумент            | **Caller saved**                                     |
| %r10    |       |       |       |                            | **Caller saved**                                     |
| %r11    |       |       |       |                            | **Caller saved**                                     |
| %r12    | %r12d | %r12w | ...   |                            | *Callee saved*                                       |
| ....    | ...   | ...   | ....  |                            | *Callee saved*                                       |
| %r15    | %r15d | %r15w | %r15b |                            | *Callee saved*                                       |
- Если хотим передать сложную структуру или больше полей, то передаем данные через Стек. Тогда указатель на вершину стека находится в `RSP`
## Соглашения о изменении переменных при вызове функции:
- Есть два типа `Caller saved` или `Callee saved`:
  - *Callee saved* - вызываемая Функция должна гарантировать, что значение регистра не именяется.
  - Caller saved -  Нет такой гарантии.
---
 
## Типы операндов:
1)  Константы: 
	   `$10`, `$-2`, `$0xff` - Константа в 16СС 
2) Регистры:
	   `%rax`, `%r8w`
3) Адреса в памяти(Внешней для процессора):
	   `0x104b` - в 16СС, `(%rax)` - Адрес из регистра. Должны указывать полный 64-битные регистры.
---

## Команды 
- `mov(Размер)`
	  `movb` - Байт
	  `movw` - Слово. Два байта
	  `movl` - Лонг. Двойное слово
	  `movq` - Quarto. Перемещение четверного слова
	`movq %rax, %rbx` (Откуда, куда)
	`movl %eax, %ebx `
	- Первый операнд - Источник (Откуда)
	- Второй операнд - Целевой операнд (Куда)

```asm
mov $0x4050, %eax

movb $-17, (%rsp) //Эта строка требует обязательного указания размера mov, тк мы не знаем, как хотим представить -17. Если указать w, то мы займем две ячейки. Если l - то 4 ячейки. q - 16 ячеек памяти.

movb (%rsp, %rdx, 4), %dl // Тут размер модем опустить. Адрес в скобках будет выражен, как %rsp + 4* %rdx.


---
movq (%rsp), (%rdx) //Команда неверна, тк одной командой из памяти в память перемещать не можем



```