# Представление чисел конечной точности в памяти компьютера
- Конечное кол-во разрядов
1) Тк у нас есть `n` - Битов, то можем представить только `2^n` чисел
2) Распределительный закон `a + (b - c) = (a+b)-c` Может не выполняться, например `a+b` может дать переполнение. 
3) Аналогично может случиться с `a(b-c)`
4) Если получили переполнение снизу, то получили Оборачивания.

## Представление целых чисел со знаком:
- Первый разряд ставим под знак. Если `0` - То число положительное. Если `1` - Отрицательное. Получатся числа `[-2^(n-1) + 1; 2^(n+1)-1]`
- Для прямого кода наша схемотехника плохо работает с отрицательными числами в **Прямом коде**, например 1 + (-1) = -2
- Для адекватного счета можем использовать  Машинный код (**обратный код**) - Дополнение до единицы
- Если у нас положительное число, то оставляем его таким же, как в *прямом коде*, а если число отрицательное, будем строить для него обратный код (Инвертированный)
- В **Обратном Коде** у нас опять числа `[-2^(n-1) + 1; 2^(n+1)-1]`

| бит1 | бит2 | бит3 | бит4 | Значение без знака | **Прямой код** | Машинный код |
| ---- | ---- | ---- | ---- | ------------------ | -------------- | ------------ |
| 0    | 0    | 0    | 0    | 0                  | 0              | 0            |
| 0    | 0    | 0    | 1    | 1                  | 1              | 1            |
| 0    | 0    | 1    | 0    | 2                  | 2              | 2            |
| 0    | 0    | 1    | 1    | 3                  | 3              | 3            |
| 0    | 1    | 0    | 0    | 4                  | 4              | 4            |
| 0    | 1    | 0    | 1    | 5                  | 5              | 5            |
| 0    | 1    | 1    | 0    | 6                  | 6              | 6            |
| 0    | 1    | 1    | 1    | 7                  | 7              | 7            |
| 1    | 0    | 0    | 0    | 8                  | -0             | -7           |
| 1    | 0    | 0    | 1    | 9                  | -1             | -6           |
| 1    | 0    | 1    | 0    | 10                 | -2             | -5           |
| 1    | 0    | 1    | 1    | 11                 | -3             | -4           |
| 1    | 1    | 0    | 0    | 12                 | -4             | -3           |
| 1    | 1    | 0    | 1    | 13                 | -5             | -2           |
| 1    | 1    | 1    | 0    | 14                 | -6             | -1           |
| 1    | 1    | 1    | 1    | 15                 | -7             | -0           |
### Попробуем сложить 1 и -1 столбиком


| 0   | 0   | 0   | 1   |
| --- | --- | --- | --- |
| 1   | 1   | 1   | 0   |
| 1   | 1   | 1   | 1   |
- Получился `-0`


### Сложим 1 и -2

| 0   | 0   | 0   | 1   |
| --- | --- | --- | --- |
| 1   | 1   | 0   | 1   |
| 1   | 1   | 1   | 0   |
- Получилось -1, что верно

### Сложим -1 и -2

| 1   | 1   | 1   | 0   |
| --- | --- | --- | --- |
| 1   | 1   | 0   | 1   |
| 1   | 0   | 1   | 1   |
- Прибавим `1`, Если есть бит переноса в старший, несуществующий разряд, и получим все **ОК**

---
---
## Дополнительный Код
- Инвертируем отрицательные числа и добавляем единицу, например была единица:
  `0001`, инвертируем и получаем `1110`, добавляем еще одну единичку и получаем `1111` - Минус единица
- Преимущество: только один нуль, и появилось еще одно отрицательное значение
- Несимметричность значений: `[-2^(n-1); 2^(n+1)-1]`

| бит1 | бит2 | бит3 | бит4 | Дополнительный Код |
| ---- | ---- | ---- | ---- | ------------------ |
| 0    | 0    | 0    | 0    | 0                  |
| 0    | 0    | 0    | 1    | 1                  |
| 0    | 0    | 1    | 0    | 2                  |
| 0    | 0    | 1    | 1    | 3                  |
| 0    | 1    | 0    | 0    | 4                  |
| 0    | 1    | 0    | 1    | 5                  |
| 0    | 1    | 1    | 0    | 6                  |
| 0    | 1    | 1    | 1    | 7                  |
| 1    | 0    | 0    | 0    | -8                 |
| 1    | 0    | 0    | 1    | -7                 |
| 1    | 0    | 1    | 0    | -6                 |
| 1    | 0    | 1    | 1    | -5                 |
| 1    | 1    | 0    | 0    | -4                 |
| 1    | 1    | 0    | 1    | -3                 |
| 1    | 1    | 1    | 0    | -2                 |
| 1    | 1    | 1    | 1    | -1                 |
### Проверим:
#### Сложим 1 и -1:
| 0   | 0   | 0   | 1   |
| --- | --- | --- | --- |
| 1   | 1   | 1   | 1   |
| 0   | 0   | 0   | 0   |
- Один бит ушел в несуществующий бит, его отбрасываем, получается все **ОК**

## Число со смещением
- Можем выбрать любое смещение, но обычно смещают на `2^(n-1)`
- x = y - 2^(n-1)
- Числа со смещением не требуют собственных правил сложения

| бит1 | бит2 | бит3 | бит4 | Код со смещением |
| ---- | ---- | ---- | ---- | ---------------- |
| 0    | 0    | 0    | 0    | -8               |
| 0    | 0    | 0    | 1    | -7               |
| 0    | 0    | 1    | 0    | -6               |
| 0    | 0    | 1    | 1    | -5               |
| 0    | 1    | 0    | 0    | -4               |
| 0    | 1    | 0    | 1    | -3               |
| 0    | 1    | 1    | 0    | -2               |
| 0    | 1    | 1    | 1    | -1               |
| 1    | 0    | 0    | 0    | 0                |
| 1    | 0    | 0    | 1    | 1                |
| 1    | 0    | 1    | 0    | 2                |
| 1    | 0    | 1    | 1    | 3                |
| 1    | 1    | 0    | 0    | 4                |
| 1    | 1    | 0    | 1    | 5                |
| 1    | 1    | 1    | 0    | 6                |
| 1    | 1    | 1    | 1    | 7                |

---
# Дробные числа

## Первая идея
- Просто представить, что после какого-то разряда лежит точка, например, пусть она лежит после второго знака, тогда `1101` будет представляться как $1*2^1 + 1 * 2^0 + 0 * 0.5 + 1*0.25 = 3.25$

## В Экспоненциальном виде:
- Мантисса - `f`, `e` - экспонента
- $x = f * 10^e$
- Но таким способом можно представить одно и то же число множеством раз.
- Представим $f \in [0.1, 1)$
- Если зафиксируем число разрядов, то можно представить как:
  

| знак числа | знак $e$ | `exp` | `exp` | МАНТИСА | МАНТИСА | МАНТИСА |
| ---------- | -------- | ----- | ----- | ------- | ------- | ------- |
|            |          |       |       |         |         |         |
- Теперь мы можем представить числа от -0.999 * 10^(-99) до 0.999 * 10^99 

- Проблема №1 - не представим ноль. Самые близкие к нулю числа: -0.1 * 10^(-99), 0.1 * 10^99
- Проблема №2 - выпадают некоторые интервалы координатной прямой.
- Проблема №3 - мы получили дискретный набор чисел, из которого выводят некоторые арифметические операции.

## Число с плавающей точкой в компьютере
- Мы представляем в виде $x = f* 2^e$
- $f \in [1, 2)$
- где мы представляем единицу в виде `1.00000...`, А двойку представляем в виде `1.111111...`

---

### Стандарт IEEE 754
- Навел большой порядок в мире цифровой техники.

----
#### Точность: 
- Одинарная точность `float` - 4 байта или 32 Бита
- Двойная точность `double` - 8 Байт или 64 Бита
- Расширенная - 10 байт, 80 Бит
#### Распределение битов на примере `float`

| 1 бит | 2 - 9 Биты (всего 8) | 10 - 32 Биты (всего 23) |
| ----- | -------------------- | ----------------------- |
| Знак  | Экспонента           | Мантисса                |
- e = `+-10^38`
- `f = 2^(-24)` Примерно `10^(-7)`
---
#### Распределение битов на примере `float`
| 1 бит | 11 Бит     | 52 Бита  |
| ----- | ---------- | -------- |
| Знак  | Экспонента | Мантисса |
- $e = +-10^{308}$ 
- $f = 2^{-54}$ примерно $10^{-16}$ 
---
#### А как кодируется Мантисс и Экспонента в `float`
##### Мантисса
- Первая в мантиссе - всегда единица, и ее можно не писать, но подразумевать. Получится 23 бит
- Экспонента кодируется со смещением `127`, это значит, что есть у нас в экспоненте `2^127`, то воспринимаем это как `2^0`  
- Ноль не представим таким способом, но в стандарте **IEEE 754** Значение нуля определено следующим способом

| Число | Знак | Мантисса | Экопонента |
| ----- | ---- | -------- | ---------- |
| 0     | +/-  | 000...   | 000...     |
| +inf  | 0    | 111...   | 000...     |
| -inf  | 1    | 111...   | 000...     |
| NaN   | 0/1  | 111...   | $\!= 1$    |
- Экспонента $e \in [-126, 127]$

--- 
#### Примеры перевода из 2СС в 10СС при помощи IEEE 754
##### 9,0 В 16СС
1) Мы должны представить в двоичном экспоненциальном виде $9/8 *2^{3} = (1 + 2^{-3}) * 2^3$
2) 3+127 = 130 = 128 + 2
3) f = 1, 0010000, единицу не учитываем, не записываем




| Знак | exp | exp | exp | exp | exp | exp | exp | exp | мант | мант | мант | мант |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | ---- | ---- | ---- | ---- |
| 0    | 1   | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0    | 0    | 1    | 0    |

= $41100000_{16}$ (переводим в 16СС при помощи деления по 4 разряда и перевода каждого в 16СС)

---

##### $42E28000_{16} = X_{2}$ 
- Переводим каждое значение отдельно 
  0100 0010 1110 0010 1000 0000 ...
- Разделяем число на биты

| Знак | exp                    | мант               |
| ---- | ---------------------- | ------------------ |
| 0    | 10000101               | 11000101000000.... |
|      | 128+4+1 = 133- 127 = 6 |                    |

- Итого: $2^{6} * (1 + 2^{-1} + 2^{-2} + 2^{6} + 2^{-8}) = 2^6 + 2^5 + 2^ 4 + 2^0 + 2^{-2} = 64 + 32 + 16 + 1 + 0.25 = 113.25$ 

---
#### Как уменьшить потерю значимости. Более точный Нуль
- К нулю мы можем приблизиться с двух сторон. Самые близкие числа -  $10^{-38}$ и $10^{-38}$
- Если договориться, что первый разряд в мантиссе не единица, а нуль, то можем получить число с фиксированной точкой
  0.1111... (23 единицы) 0.00000...1 (23-ий бит - единица)
- Там, где первый бит - Единица - **Нормализованный тип**. Где нуль - **Ненормализованный**


| Знак | exp    | Мантисса   |
| ---- | ------ | ---------- |
| 0/1  | 00...0 | не 00...00 |
- Ненормализованный вариант

- Это позволяет нам ближе придвинуться к нулю: $-10^{-52}$ и $10^{-52}$
- Это произошло, тк мы считаем, что у мантиссы первый символ - **не единица, а нуль** и точка фиксирована
---
# Задача: 
- Написать функцию, которая бы выводила числа в их двоичном представлении
```cpp
#include <iostream>  
#include <cstring>  
  
  
void printFloatBinary(float a) {  
    std::string out = "";  
  
    unsigned int binary;  
    std::memcpy(&binary, &a, sizeof(a));  
  
  
    for (int i = 31; i >= 0; --i) {  
        std::cout << ((binary >> i) & 1);  
        if (31 == i || 31 - 8 == i) std::cout << " ";  
  
    }    std::cout << "\n";  
    std::cout << std::hex << binary << "\n";  
}  
  
int main(){  
    float C = 9.0;  
    // std::cin >> C;  
    printFloatBinary(9.0);  
    return 0;  
}
// Out: 
// 0 10000010 00100000000000000000000
// 41100000

```
