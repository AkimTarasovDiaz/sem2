## Семинар 8

### На предыдущем занятияи... 
mov_ (b,w,l,q)

Любые команды на языке ассемблера могут оперировать разными количествами аргументов, у инструкции мув 2(откуда и куда) операндов
```shell
mov %r2x, (%rsp_) 
```
(первый - регистр, второй - адрес в памяти? можем перед скобочками указать число и это будет сдвигом, например 4(%rsp) - %rsp + 4)
(регистр из которого берем значение сразу подсказывает, что это полный регистр занимающий 8 байт, можно q указывать можно нет)

Регистр %r2x (8 байт) %e2x (4 байт) - половина регистра, %2x (2 байта) - четверть регистра, %2l (8 бит)

$-1 - константа минус единица 

$0xff -то же самое. Убирая доллар будет просто адрес в памяти.

команда mov может читать из адреса и записывать по адресу, если я хочу что-то из памяти записать в память - то 2 мува, одной командой я не справлюсь

### Допустим... 
```c
void decode1(long *xp, long *yp, long *zp);
```
И к нам в руки попал ассемблерный код:
```shell
decode1:                     //метка 
    movq (%rdi), %r8         //rdi, rsi, rax - первые 3 аргумента. rdi - xp, rsi - yp, rax - zp
                             // по сути разыменовываем указатель xp и переносим в r8 и тд
    movq (%rsi), %rcx
    movq (%rdx), %rax
    movq %r8, (%rsi)
    movq %rcx, (%rdx)
    movq %rax, (%rdi)
    ret
``` 
Первым делом надо определить что мы передаем в функцию. Long * это всего лишь тип, это не повлияло бы ни на что. По сути мы обмениваемся памятью и все. Мы можем по машинному коду можем достаточно точно восстановить ассемблерный код, но по ассмеблерному коду достаточной сложно восстановить код на высокоуровневом языке
```c
void decode1(long *xp, long *yp, long *zp){
    long x = *xp;
    long y = *yp;
    long z = *zp; //в качестве переменных могут выступать регистры
    *yp = x;
    *zp = y;
    *xp = z;
}
```
вот так могла выглядеть функция. Мы не всегда можем выстраивать прям строчка в строчку между высокоуровневым кодом и низкоуровневым. Это все было повторение команды мув

### Продолжаем!
movz и movs - нужны чтобы записывать данные из ячейки меньшего размера в ячейки большего (расширяем нулями и знаком (zero и sign))

-1 в шестнадцатиричном коде 0xff в 1 байте. В 2 байтах - 0xffff

movz -> 0x00ff; movs -> 0xffff  

movzbw movzbv - из байта в 2 байта

А вот для команды movz отсутствует вариант инструкции movzlq, со старшими байтами что случица?

```shell
movb $-1, %al
```
перенесет один байтик, перенесет младший байти в конец регистра. 1 байт переносим - состояние старших байтов не меняется 
Переносим 2 байта - ff ff , то последние 2 байта будут закодированы минус единицей.
```shell
movl $-1, %eax
```
Младшие 4 байта будут ffffffff, а старшие байты занулятся

movzlq должна перенести 4 младших байта и занулить 4 старших байта, но тот же эффект будет от movl, такой команды НЕТ

### Продолжаем

```shell
define < существующий тип > < псевдоним >                     | typedef long src_t;   | typedef signed char src_t;
src_t *sp;                                                    | typedef long dest_t;  | typedef int dest_t;
dest_t *dp;
*dp = (dest_t) *sp;

sp <- B %rdi, dp <- в %rsi
movq (%rdi), %rax
movq %rax, (%rsi)

```

```shell
src_t *sp;                                                    | typedef signed char src_t;
dest_t *dp;                                                   | typedef int dest_t;
*dp = (dest_t) *sp;

sp <- B %rdi, dp <- в %rsi
movsbl (%rdi), %eax
movl %eax, (%rsi)
```

### Рассмотрим новую команду leaq
Только с 8 байтовыми значениями 
movq - leaq

```shell
leaq (%rdi), %rax //вычислит адресс на первом месте, но она запишет адрес в %rax
movq %rdi, %rax // полная эквивалентность
//         регистры:
// число (база, индекс, шаг(1,2,4,8,))
// адрес = сдвиг + база + индекс * шаг
```

### Примеры
#### 1

```shell
leaq (%rax, %rax, 4), %rdx 
// %rdx = x + y * 4 - компилятор скорее всего воспользуется leaq
``` 

```shell
leaq (%rax, %rcx, 4), %rdx 
// %rax + %rax * 5
```

#### 2
Пусть у нас есть:

```c
long scale2(long x, long y, long z) { 
    long t = ...; // long t = 5 * x + 2 * y + 8 * z
    return t;
}
```
```shell
scale2:
    leaq (%rdi, %rdi, 4), %rax            |5x
    leaq (%rax, %rsi, 2), %rax            |5x+2y
    leaq (%rax, %rdx, 8), %rax            |5x+2y+8
    ret
```

### Унарные бинарные операции
Вот некоторые унарные операции:
```shell
INC (инкремент)
DEC (декремент)
NEC (противоположный знак)
NOT (инверсися значения инк)
```
Бинарные операции:
```shell
ADВ 
SUM 
IMUL
AND
OR
XOR
```