// 20 80 - 80% проекта делается за 20% времени и обратно
#include <iostream> 
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;
using Original=Node*;
using Copy=Node*;

// деревья опять, откроем википедию - самобалансирующее деревья. Но splay деревья не самобаланс
// есть какое-то дерево, давайте после каждого запроса, будет следующий запрос, я буду поворачивать вершинку так, чтобы моя вершинка была zik zik-zik и zik-zak
// это дерево для конкретной задачи, когда запросы одинаковые или запросы рядом - splay дерево
// амортизированные повороты за логарифм
//
// теперь хэш таблицы
// что с ними? Бин дерево поиска дают да логарифм в сбалансированных деревьях
// иногда хотим искать элементы за o(1), для этого служат хэш таблицы
// способы организации хэш таблицы ? 
// хэш? какой принцип? КОгда у нас есть любой объект, перед тем как положить мы высчитываем хэш, хэш нам дает корзину, и туда кладем
// только могут быть корзины где есть еще что-то
// хэш - по сути номер
// берем объект, натравливаем хэш функцию, выдает нам 01 02 03 04
// считаем хэш, идем в корзину, и перебираем объекты только в корзине
// 1ое - корзины |_|_|_|_|
//               01 2 3 4 
// в каждом элементе есть односвязный список
// можно и массив
// это метод цепочек, можно увидеть 
// для того чтобы мы разместили элемент в хэш таблице нужны оператор равно и хэш функция
// теперь рехеширование - увеличиваем количество корзин
// если брать другую функцию, будет тяжело, 
// подается хеш функция которая выдает значение в size_t
// чтобы из одного в другой перевести (чтобы массив не был гигантского размера)
// считаем size_t%count
// count увеличиваем в два раза, оп еще 4 корзины образовалось - рехеширование (т, амортизировано 1)
// элементы лежат в хэш корзине
// то что было там возможно окажется 
// геморный 2 способ - 
// берем и выделяем массив так чтобы количество (если надо 75 - то выделяем на 100)
// вычисляем хэш и кладем элементы (хэши 01 и 03)
// выдала функция 01 опять - там занято, первое что было придумано - смещение на единичку вперед
// если надо допустим разместить следующий - (разместили еще элементы)
// при прыжках на один где что-то лишнее - прыгаем дальше до свободного
// проблема 1 - линейный поиск - нужны фейковые элементы 
// проблема 2 - при таком способе занимаем чужие места, встречаются элементы которые не соответсвуют своим хэшам
// приходится ставить Null неугодным, если 01 придет - мы поставим вместо Null 01, иначе разобьем поиск, держим информацию про прыгай дальше
// много гемора
// кластеризация - все перемешалось 
// с этим стали бороться, прыгать линейно, или ищем I и прыгаем по какому-то закону 
// 
// про хэщ функции - интересная вещь, берет элемент и возвращает целое (для удобства) число, уникальность, нужно равномерное распределение с равной вероятностью
//
// unordered set - хэш таблица 
// unordered map 
// дальше полиномы какие-то 
// a+a1p+...
// a+p(a1+p(a1 ....
// для std::pair - xor
// вычисляем хэш от first и делаем hash(first) ^ hash(second) дает примерно равномерное распределение для данных
// иногда данные неравномерны тогда стоит как-то пересмотреть функцию и написать свою
// в яндексе чувак был 
// коллизия одна из причин кластеризации
// колизии есть всегда, функция кидает в корзину, если в корзине разные элементы (с одним хэшем)
// n-цепочек и 
// есть хорошая хэш функция которая работает за константу
// далеко не каждый объект можно хэшировать
// для бин дерева не для каждого можно оператор сравнения написать
//
//задачка
// одна из реализаций списка смежности
struct  Node
{
    int val;
    vector<Node*> nodes;
    // вместо Node* был бы pair<Node*, int> если бы был взвешенный 
}; //не взвешенный и ориентированный граф
//задача - есть граф односвязный(из любой вершины можно пойти в любую), задан такой структурой, для того чтобы его скопировать нужно
//2 проблемы - допустим есть граф - начинаем копировать и может быть, что можем получить при (1)->(2)->(2) => (1)->(2)->(2)->(1)
Node* CopyGraph(Node* node) {
    if (!node) {return node;}
    Copy copy = new Node;
    copy->val=node->val;
    unordered_map<Original, Copy> n2n; //ориг и копия
    queue<Node*> q;
    n2n[node]=copy;
    q.push(node); //тут какие-то вершины на обработку, как поиск в ширину
    while (q.size()) {
        Node* n = q.front();
        q.pop(); 
        Node* copycopy = n2n[n]; // создастся новый элемент на n и опасно это! добавляя в очередь - она гарантированно будет в n2n
        for (Node* adj: n->nodes) {
            auto it = n2n.find(adj);
            if (it!=n2n.end()) {
                copy->nodes.push_back(it->second);
            } else {
                Node* c = new Node;
                c->val = adj->val;
                n2n[adj] = c;
                q.push(adj);
            }
        }
        return copy; 
    }
}