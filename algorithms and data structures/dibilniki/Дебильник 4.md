# Темы:
1) Хэш-функция. что такое? Зачем? Правила построения
2) Хэш таблица. Открытая адресация
3) Хэш таблица. Метод цепочек

---
---


## **1. Хеш-функция: что это, зачем и правила построения**

### **Определение**
Хеш-функция — это алгоритм, преобразующий произвольные данные (строки, объекты) в числовой хеш-код фиксированного размера (обычно целое число).

### **Зачем нужна?**
- Позволяет быстро искать данные за **O(1)** в среднем случае
- Используется в хеш-таблицах, криптографии, кэшировании
- Дает "уникальный" идентификатор объекта

### **Правила построения хорошей хеш-функции**
1. **Детерминированность**: Один и тот же вход → одинаковый хеш
2. **Равномерность**: Хеши должны равномерно распределяться
3. **Минимизация коллизий**: Разные входы → по возможности разные хеши
4. **Быстрота вычисления**: O(1) или O(n) от размера данных
5. **Устойчивость**: Малое изменение входа → значительное изменение хеша

### **Примеры хеш-функций**
```cpp
// Для строк (упрощенный вариант)
size_t hashString(const string& s) {
    size_t hash = 0;
    for (char c : s) {
        hash = hash * 31 + c;  // 31 — простое число
    }
    return hash;
}

// Для целых чисел (тривиальный случай)
size_t hashInt(int x) {
    return x;
}
```

- **Идеальная хеш-функция** — когда для всех возможных входов нет коллизий (редко достижимо)
- **Универсальное хеширование** — использование семейства хеш-функций для защиты от атак

---

## **2. Хеш-таблица с открытой адресацией**

### **Суть метода**
- Все элементы хранятся **в самом массиве** (без списков)
- При коллизии ищется следующая свободная ячейка

### **Стратегии поиска места**
1. **Линейное пробирование**: `hash(key) + i % size`
2. **Квадратичное пробирование**: `hash(key) + i² % size`
3. **Двойное хеширование**: `hash1(key) + i*hash2(key) % size`

### **Проблемы**
- **Кластеризация**: Образование "блоков" занятых ячеек
- **Удаление**: Требуется специальная пометка "удалено" (не просто NULL)

### **Пример реализации (линейное пробирование)**
```cpp
class HashTable {
    vector<pair<int, string>> table;
    vector<bool> deleted;
    
    size_t hash(int key) { return key % table.size(); }
    
public:
    void insert(int key, string value) {
        size_t idx = hash(key);
        while (!table[idx].empty() && !deleted[idx]) {
            idx = (idx + 1) % table.size();
        }
        table[idx] = {key, value};
        deleted[idx] = false;
    }
    
    string find(int key) {
        size_t idx = hash(key);
        while (true) {
            if (table[idx].first == key && !deleted[idx]) 
                return table[idx].second;
            if (table[idx].empty() && !deleted[idx]) 
                return "";
            idx = (idx + 1) % table.size();
        }
    }
};
```

- **Коэффициент заполнения** (load factor): При превышении порога (обычно 0.7) таблицу расширяют
- **Альтернативы**: Метод Робин Гуда (перемещение старых элементов)

---

## **3. Хеш-таблица с методом цепочек**

### **Суть метода**
- Каждая ячейка массива содержит **список** (цепочку) элементов
- При коллизии элементы добавляются в список

### **Преимущества перед открытой адресацией**
- Нет проблем с кластеризацией
- Проще удаление элементов
- Выдерживает высокий load factor (>1)

### **Пример реализации**
```cpp
class HashTable {
    vector<list<pair<int, string>>> table;
    
    size_t hash(int key) { return key % table.size(); }
    
public:
    void insert(int key, string value) {
        size_t idx = hash(key);
        for (auto& p : table[idx]) {
            if (p.first == key) {
                p.second = value;  // Обновление
                return;
            }
        }
        table[idx].push_back({key, value});
    }
    
    string find(int key) {
        size_t idx = hash(key);
        for (auto& p : table[idx]) {
            if (p.first == key) {
                return p.second;
            }
        }
        return "";
    }
};
```

- **Оптимизации**:
  - Использование BST вместо списков (время поиска O(log n) при коллизиях
  - Динамическое увеличение размера таблицы при росте цепочек
- **Рехеширование**: При увеличении размера все элементы пересчитываются

---

## **Сравнение методов**

| Критерий          | Открытая адресация       | Метод цепочек          |
|-------------------|--------------------------|------------------------|
| **Память**        | Экономичнее (нет указателей) | Требует больше памяти |
| **Кластеризация** | Есть проблема            | Нет проблемы           |
| **Удаление**      | Сложное (метка "удалено")| Простое               |
| **Load factor**   | Рекомендуется ≤ 0.7      | Может быть > 1         |
| **Производительность** | Быстрее при малых данных | Стабильнее при росте   |

---

## **Вывод**
- **Хеш-функция** — основа работы таблицы, должна быть быстрой и равномерной
- **Открытая адресация** — эффективна по памяти, но страдает от кластеризации
- **Метод цепочек** — проще в реализации, стабильнее при нагрузке

**Где что использовать?**
- `unordered_map` в C++ — метод цепочек
- Redis, Python dict — открытая адресация
- Для маленьких данных — открытая адресация
- Для частых удалений — метод цепочек