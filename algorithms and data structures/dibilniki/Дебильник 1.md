# Вопросы к дебильнику
1) что такое динамический массив, его представление в с++?
2) списки, их представления в с++?
3) очередь, её представление в с++?
4) стек, её представление в с++?
5) дек?
6) бинарный поиск?
---

# Разбор вопросов:

## **Что такое динамический массив, его представление в с++?**

#### **1. Определение**

Динамические массивы — это массивы, память для которых выделяется и освобождается **вручную** во время выполнения программы (в отличие от статических массивов, размер которых фиксирован на этапе компиляции).

#### **2. Создание динамического массива**

Для работы с динамическими массивами в C++ используются:

* Оператор **`new`** — выделяет память в **куче (heap)**.
* Оператор **`delete[]`** — освобождает выделенную память (во избежание утечек).

**Пример:**

```cpp
int size = 5;
int* arr = new int[size]; // выделение памяти под массив из 5 элементов
```

#### **3. Инициализация и доступ к элементам**

Доступ к элементам осуществляется так же, как в обычных массивах — через индекс.

```cpp
arr[0] = 10;  // запись
cout << arr[0]; // чтение
```

#### **4. Освобождение памяти**

**Обязательно** освобождать память, иначе будет **утечка памяти (memory leak)**.

```cpp
delete[] arr; // освобождение памяти
arr = nullptr; // хороший стиль — обнуление указателя
```

#### **5. Изменение размера массива**

Динамические массивы **не могут** автоматически менять размер (в отличие от `std::vector`). Для изменения размера нужно:

1. Создать новый массив нужного размера.
2. Скопировать старые данные.
3. Удалить старый массив.

**Пример:**

```cpp
int* resizeArray(int* oldArr, int oldSize, int newSize) {
    int* newArr = new int[newSize];
    for (int i = 0; i < min(oldSize, newSize); i++) {
        newArr[i] = oldArr[i];
    }
    delete[] oldArr;
    return newArr;
}
```

#### **6. Проблемы динамических массивов**

* **Утечки памяти**, если не вызвать `delete[]`.
* **Выход за границы массива** (нет проверки индексов).
* **Неудобство** по сравнению с `std::vector`.

#### **7. Альтернатива — `std::vector`**

В C++ лучше использовать **`std::vector`** из STL, который:

* Автоматически управляет памятью.
* Может динамически расти.
* Безопаснее и удобнее.

**Пример:**

```cpp
#include <vector>
std::vector<int> vec = {1, 2, 3};
vec.push_back(4); // добавление элемента
```

---
---




## **4. Двусвязный и односвязный список. Операции.**

### **1. Односвязный список (Singly Linked List)**

#### **Определение**

Односвязный список — это структура данных, состоящая из узлов, где каждый узел содержит:

* **Данные** (значение)
* **Указатель (ссылку)** на следующий узел

Последний узел указывает на `nullptr` (конец списка).

#### **Основные операции**

1. **Вставка в начало** (`push_front`)
   * Создаём новый узел
   * Новый узел указывает на старую голову
   * Голова списка теперь — новый узел
   * **Сложность: O(1)**
2. **Удаление из начала** (`pop_front`)
   * Запоминаем старую голову
   * Перемещаем голову на следующий узел
   * Удаляем старую голову
   * **Сложность: O(1)**
3. **Вставка/удаление в произвольное место**
   * Требуется обход списка до нужной позиции
   * **Сложность: O(n)**

#### **Плюсы**

* Динамическое расширение (не требует непрерывной памяти)
* Быстрое добавление/удаление в начало
* Эффективнее по памяти, чем двусвязный список

#### **Минусы**

* Нет доступа по индексу (только последовательный обход)
* Медленные вставка/удаление в конец (O(n))
* Нельзя перемещаться назад

```cpp
template <typename T>
class SinglyLinkedList {
    struct Node {
        T data; // Хранит данные типа T
        Node* next; // Указатель на следующий узел
    };
  
    Node* head; // Указатель на первый узел списка
  
public:
    // Конструктор
    SinglyLinkedList() : head(nullptr) {}
  
    // Деструктор
    ~SinglyLinkedList() {
        while (head) {
            remove_front();
        }
    }
    // Вставка в начало
    void insert_front(T value) {
        Node* new_node = new Node{value, head}; // 1. Создаём новый узел
        head = new_node; // 2. Делаем его головой списка
    }
  
    // Удаление из начала
    void remove_front() {
        if (head) {    // 1. Проверяем, что список не пуст
            Node* temp = head; // 2. Запоминаем текущую голову
            head = head->next; // 3. Перемещаем голову на следующий узел
            delete temp;  // 4. Освобождаем память старой головы
        }
    }
    // Вставка после указанной позиции (по индексу)
    void insert_after(int index, T value) {
        if (index < 0) return; // Невалидный индекс
  
        Node* current = head;
        // Ищем узел с нужным индексом
        for (int i = 0; current != nullptr && i < index; ++i) {
            current = current->next;
        }
  
        if (current != nullptr) {
            Node* new_node = new Node{value, current->next};
            current->next = new_node;
        }
        // Если current == nullptr, индекс за пределами списка - ничего не делаем
    }

// Удаление по индексу
    void remove_at(int index) {
        if (index < 0 || head == nullptr) return; // Невалидный индекс или пустой список
  
        if (index == 0) {
            remove_front();
            return;
        }
  
        Node* current = head;
        // Ищем узел ПЕРЕД тем, который нужно удалить
        for (int i = 0; current != nullptr && i < index - 1; ++i) {
            current = current->next;
        }
  
        // Проверяем, что нашли узел и после него есть что удалять
        if (current != nullptr && current->next != nullptr) {
            Node* temp = current->next;
            current->next = temp->next;
            delete temp;
        }
    }
};
```

### **2. Двусвязный список (Doubly Linked List)**

#### **Определение**

Двусвязный список — это список, где каждый узел содержит:

* **Данные**
* **Указатель на следующий узел**
* **Указатель на предыдущий узел**

Первый узел (`head`) имеет `prev = nullptr`, последний (`tail`) — `next = nullptr`.

#### **Основные операции**

1. **Вставка в начало/конец** (`push_front`, `push_back`)
   * Аналогично односвязному, но с обновлением `prev`
   * **Сложность: O(1)**
2. **Удаление из начала/конца** (`pop_front`, `pop_back`)
   * **Сложность: O(1)**
3. **Вставка/удаление в произвольное место**
   * Доступ к соседним узлам через `prev` и `next`
   * **Сложность: O(n)** (но быстрее, чем в односвязном)

#### **Плюсы**

* Возможность обхода в обе стороны
* Быстрые операции с началом и концом списка
* Удобен для реализации двусторонних очередей (`deque`)

#### **Минусы**

* Тратит больше памяти на хранение дополнительного указателя
* Сложнее в реализации

```cpp
#include <iostream>
#include <stdexcept>

template <typename T>
class DoublyLinkedList {
private:
    struct Node {
        T data; // Хранит данные типа T (шаблонный параметр)
        Node* prev; // Указатель на предыдущий узел
        Node* next; // Указатель на следующий узел
  
        Node(const T& val) : data(val), prev(nullptr), next(nullptr) {}
    };
  
    Node* head;  // Указатель на первый узел списка
    Node* tail; // Указатель на последний узел списка
    size_t size; // Текущее количество элементов в списке
  
public:
    // Конструктор
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}
  
    // Деструктор
    ~DoublyLinkedList() {
        clear();
    }
  
    // Проверка на пустоту
    bool empty() const {
        return size == 0;
    }
  
    // Получение размера
    size_t get_size() const {
        return size;
    }
  
    // Очистка списка
    void clear() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
        tail = nullptr;
        size = 0;
    }
  
    // 1. Вставка в начало (O(1))
    void push_front(const T& value) {
        Node* new_node = new Node(value);  // Создаем новый узел
  
        if (empty()) {
            head = tail = new_node;
        } else {
            new_node->next = head; // Новый узел указывает на текущую голову
            head->prev = new_node; // Текущая голова указывает назад на новый узел
            head = new_node; // Новый узел становится новой головой
        }
        size++;
    }
  
    // 1. Вставка в конец (O(1))
    void push_back(const T& value) {
        Node* new_node = new Node(value); // Создаем новый узел
  
        if (empty()) {
            head = tail = new_node;
        } else {
            tail->next = new_node; // Текущий хвост указывает на новый узел
            new_node->prev = tail; // Новый узел указывает назад на текущий хвост
            tail = new_node;  // Новый узел становится новым хвостом
        }
        size++;
    }
  
    // 2. Удаление из начала (O(1))
    void pop_front() {
        if (empty()) {
            throw std::out_of_range("List is empty");
        }
  
        Node* temp = head;
        head = head->next;
  
        if (head) {
            head->prev = nullptr;
        } else {
            tail = nullptr;
        }
  
        delete temp;
        size--;
    }
  
    // 2. Удаление из конца (O(1))
    void pop_back() {
        if (empty()) {
            throw std::out_of_range("List is empty");
        }
  
        Node* temp = tail;
        tail = tail->prev;
  
        if (tail) {
            tail->next = nullptr;
        } else {
            head = nullptr;
        }
  
        delete temp;
        size--;
    }
  
    // 3. Вставка в произвольное место (O(n))
    void insert_at(size_t index, const T& value) {
        if (index > size) {
            throw std::out_of_range("Index out of range");
        }
  
        if (index == 0) {
            push_front(value);
        } else if (index == size) {
            push_back(value);
        } else {
            Node* current = get_node(index);  // Находим узел в позиции index
            Node* new_node = new Node(value); // Создаем новый узел
  
            // Связываем новый узел с соседями
            new_node->prev = current->prev;
            new_node->next = current;
  
            // Обновляем соседей
            current->prev->next = new_node;
            current->prev = new_node;
  
            size++;
        }
    }
  
    // 3. Удаление из произвольного места (O(n))
    void remove_at(size_t index) {
        if (index >= size) {
            throw std::out_of_range("Index out of range");
        }
  
        if (index == 0) {
            pop_front();
        } else if (index == size - 1) {
            pop_back();
        } else {
            Node* to_delete = get_node(index);
  
            // Перенаправляем указатели соседей
            to_delete->prev->next = to_delete->next;
            to_delete->next->prev = to_delete->prev;
  
            delete to_delete;
            size--;
        }
    }
  
    // Получение элемента по индексу
    T& at(size_t index) {
        Node* node = get_node(index);
        return node->data; // Возвращаем ссылку на данные узла
    }
  
private:
    // Вспомогательная функция для получения узла по индексу
    Node* get_node(size_t index) const {
        if (index >= size) {
            return nullptr;
        }
  
        // Оптимизация: выбираем направление обхода
        if (index < size / 2) {
            Node* current = head;
            for (size_t i = 0; i < index; ++i) {
                current = current->next;
            }
            return current;
        } else {
            Node* current = tail;
            for (size_t i = size - 1; i > index; --i) {
                current = current->prev;
            }
            return current;
        }
    }
};

```

---
---



## **3 Очередь и ее представление в C++**
#### **1. Определение**

**Очередь** — это структура данных, работающая по принципу **FIFO (First In, First Out)** — "первым пришёл, первым вышел".

* Элементы добавляются в **конец** (tail) и извлекаются из **начала** (head).
* Аналогия: очередь в магазине — первый встал в очередь, первый и обслужился.

#### **2. Основные операции**


| Операция  | Описание                    | Сложность |
| --------- | --------------------------- | --------- |
| `enqueue` | Добавление элемента в конец | O(1)      |
| `dequeue` | Удаление элемента из начала | O(1)      |
| `front`   | Чтение первого элемента     | O(1)      |
| `isEmpty` | Проверка на пустоту         | O(1)      |
| `size`    | Получение размера очереди   | O(1)      |

#### **3. Реализация на C++ (на основе связного списка)**

```cpp
#include <iostream>
#include <stdexcept>

template <typename T>
class Queue {
private:
    struct Node {
        T data;
        Node* next;
        Node(const T& value) : data(value), next(nullptr) {}
    };
  
    Node* head;  // Указатель на начало очереди
    Node* tail;  // Указатель на конец очереди
    int count;   // Количество элементов

public:
    Queue() : head(nullptr), tail(nullptr), count(0) {}

    ~Queue() {
        while (!isEmpty()) {
            dequeue();
        }
    }

    // Добавление элемента в конец
    void enqueue(const T& value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        count++;
    }

    // Удаление элемента из начала
    void dequeue() {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        Node* temp = head;
        head = head->next;
        delete temp;
        count--;
        if (isEmpty()) {
            tail = nullptr;
        }
    }

    // Чтение первого элемента
    T front() const {
        if (isEmpty()) {
            throw std::out_of_range("Queue is empty");
        }
        return head->data;
    }

    // Проверка на пустоту
    bool isEmpty() const {
        return count == 0;
    }

    // Получение размера
    int size() const {
        return count;
    }
};
```

#### **4. Особенности реализации**

1. **На основе связного списка**:

   * Динамическое расширение (нет ограничения по размеру).
   * Операции `enqueue`/`dequeue` работают за O(1).
2. **Альтернативная реализация** на массиве (циклический буфер):

   * Фиксированный размер, но более эффективен по памяти.
   * Требует обработки переполнения.
3. **Стандартная очередь в C++ (`std::queue`)**:

   ```cpp
   #include <queue>
   std::queue<int> q;
   q.push(10);  // enqueue
   q.pop();     // dequeue
   ```

#### **5. Применение очередей**

1. **Задачи планирования** (например, процессы в ОС).
2. **Буферизация данных** (ввод-вывод, сетевые пакеты).
3. **Работа с базами данных** (создание очередей исполнения команд).

---
---


## **4 Стек и его представление в C++**
**LIFO (Last In First Out)** - последним пришел, первым ушел.

#### **1. Определение**

**Стек** — это структура данных, работающая по принципу **LIFO (Last In, First Out)** — "последним пришёл, первым вышел".

* Добавление и удаление элементов происходит **только с одного конца** (вершины стека).
* Аналогия: стопка тарелок — новую кладут сверху и сверху же берут.

#### **Основные операции**

Все операции выполняются за **O(1)** (константное время):


| Операция | Описание                                                            | Пример (C++)     |
| ---------------- | --------------------------------------------------------------------------- | ---------------------- |
| **push**         | Добавление элемента на вершину стека        | `stack.push(10)`       |
| **pop**          | Удаление элемента с вершины                         | `stack.pop()`          |
| **top**          | Чтение элемента на вершине (без удаления) | `int x = stack.top()`  |
| **empty**        | Проверка на пустоту                                        | `if (stack.empty())`   |
| **size**         | Получение количества элементов                  | `int s = stack.size()` |

**Реализация стека**

Стек можно реализовать:

1. **На массиве** (статический размер):
   * Фиксированная ёмкость.
   * Быстрый доступ, но может переполниться.
2. **На односвязном списке** (динамический размер):
   * `push`/`pop` работают с головой списка.
   * Не ограничен по размеру.

**Реализация на массиве**:

```cpp
#include <iostream>
#include <stdexcept> // Для std::out_of_range

template <typename T>
class ArrayStack {
private:
    T* data;         // Указатель на массив элементов
    int capacity;    // Максимальный размер стека
    int topIndex;    // Индекс вершины стека (-1 означает пустой стек)

public:
    // Конструктор с заданным размером
    explicit ArrayStack(int size) : capacity(size), topIndex(-1) {
        if (size <= 0) {
            throw std::invalid_argument("Stack size must be positive");
        }
        data = new T[size];
    }

    // Деструктор
    ~ArrayStack() {
        delete[] data;
    }

    // Явно удаляет конструктор копирования
    ArrayStack(const ArrayStack&) = delete;
    // Явно удаляет оператор присваивания
    ArrayStack& operator=(const ArrayStack&) = delete;

    // Добавление элемента на вершину стека
    void push(const T& value) {
        if (isFull()) {
            throw std::out_of_range("Stack overflow");
        }
        data[++topIndex] = value;
    }

    // Удаление элемента с вершины стека
    T pop() {
        if (isEmpty()) {
            throw std::out_of_range("Stack underflow");
        }
        return data[topIndex--];
    }

    // Просмотр вершины стека
    const T& top() const {
        if (isEmpty()) {
            throw std::out_of_range("Stack is empty");
        }
        return data[topIndex];
    }

    // Проверка на пустоту
    bool isEmpty() const {
        return topIndex == -1;
    }

    // Проверка на полноту
    bool isFull() const {
        return topIndex == capacity - 1;
    }

    // Получение текущего размера стека
    int size() const {
        return topIndex + 1;
    }

    // Получение максимальной емкости
    int getCapacity() const {
        return capacity;
    }
};

```

#### **Стек в STL (`std::stack`)**

```cpp
#include <stack>
std::stack<int> s;
s.push(10); // Добавить
s.pop();    // Удалить
int x = s.top(); // Прочитать вершину
```

---
---




## **5. Дек (двусторонняя очередь)**

#### **1. Определение**

**Дек** (Double-ended queue) — это структура данных, позволяющая добавлять и удалять элементы **с обоих концов** (начало и конец).

* Поддерживает принципы **FIFO** (как очередь) и **LIFO** (как стек).
* Аналогия: двусторонняя очередь, где можно вставать/выходить и с начала, и с конца.

#### **2. Основные операции**


| Операция | Описание                                   | Сложность |
| ---------------- | -------------------------------------------------- | ------------------ |
| `push_front`     | Добавление в начало               | O(1)               |
| `push_back`      | Добавление в конец                 | O(1)               |
| `pop_front`      | Удаление из начала                 | O(1)               |
| `pop_back`       | Удаление из конца                   | O(1)               |
| `front`          | Чтение первого элемента       | O(1)               |
| `back`           | Чтение последнего элемента | O(1)               |
| `isEmpty`        | Проверка на пустоту               | O(1)               |
| `size`           | Получение размера                  | O(1)               |


#### **3. Реализация на C++ (на основе двусвязного списка)**

```cpp
#include <iostream>
#include <stdexcept>

template <typename T>
class Deque {
private:
    struct Node {
        T data;
        Node* prev;
        Node* next;
        Node(const T& value) : data(value), prev(nullptr), next(nullptr) {}
    };

    Node* head;  // Указатель на начало
    Node* tail;  // Указатель на конец
    int count;   // Количество элементов

public:
    Deque() : head(nullptr), tail(nullptr), count(0) {}

    ~Deque() {
        while (!isEmpty()) {
            pop_front();
        }
    }

    // Добавление в начало
    void push_front(const T& value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode->next = head;
            head->prev = newNode;
            head = newNode;
        }
        count++;
    }

    // Добавление в конец
    void push_back(const T& value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            head = tail = newNode;
        } else {
            newNode->prev = tail;
            tail->next = newNode;
            tail = newNode;
        }
        count++;
    }

    // Удаление из начала
    void pop_front() {
        if (isEmpty()) {
            throw std::out_of_range("Deque is empty");
        }
        Node* temp = head;
        head = head->next;
        if (head) {
            head->prev = nullptr;
        } else {
            tail = nullptr; // Если дек стал пустым
        }
        delete temp;
        count--;
    }

    // Удаление из конца
    void pop_back() {
        if (isEmpty()) {
            throw std::out_of_range("Deque is empty");
        }
        Node* temp = tail;
        tail = tail->prev;
        if (tail) {
            tail->next = nullptr;
        } else {
            head = nullptr; // Если дек стал пустым
        }
        delete temp;
        count--;
    }

    // Чтение первого элемента
    T front() const {
        if (isEmpty()) {
            throw std::out_of_range("Deque is empty");
        }
        return head->data;
    }

    // Чтение последнего элемента
    T back() const {
        if (isEmpty()) {
            throw std::out_of_range("Deque is empty");
        }
        return tail->data;
    }

    // Проверка на пустоту
    bool isEmpty() const {
        return count == 0;
    }

    // Получение размера
    int size() const {
        return count;
    }
};
```

#### **5. Особенности реализации**

1. **Двусвязный список**:

   * Позволяет эффективно (O(1)) добавлять/удалять элементы с обоих концов.
   * Динамически расширяется.
2. **Альтернатива: циклический буфер** (на массиве):

   * Фиксированный размер, но более эффективен по памяти.
   * Требует обработки переполнения.
3. **Стандартный дек в C++ (`std::deque`)**:

   ```cpp
   #include <deque>
   std::deque<int> dq;
   dq.push_front(5);  // В начало
   dq.push_back(10);  // В конец
   ```

#### **6. Применение дека**

1. **Алгоритмы скользящего окна** (например, поиск максимума в подмассивах).
2. **Планировщики задач** с приоритетами на обоих концах.
3. **Отмена действий** (Undo/Redo) в редакторах.
4. **Реализация стека и очереди** одновременно.

---
---


## **6 Бинарный поиск**

#### **Бинарный поиск (O(log n), работает только на отсортированном массиве):**

```cpp
int binarySearch(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1; // не найдено
}
```