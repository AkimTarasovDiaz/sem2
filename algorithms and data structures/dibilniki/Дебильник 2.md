
---
# Предисловие:
> Конспект подготовлен Игорем Н. Из группы *Б03-414*. Он основан на личных познаниях, открытой информации из интернета и [Конспекту Билала](https://github.com/billyshmil059/algorithms/blob/main/Sorts.md). Отдельная благодарность ему за это, в некоторых местах его конспект очень точно описывает работу алгоритмов сортировки


---
---



# Вопросы к дебильнику 
1) merge sort
2) quick sort, k-ая порядковая статистика
3) heap sort, очередь с приоритетом
4) теорема о скорости сортировки (формулировка) и устойчивость сортировки
5) сортировка подсчётом и поразрядная сортировка
6) Тим сорт

---

# Разбор вопросов:

## 1) merge sort (Сортировка слиянием)

**Принцип работы:**
1. Рекурсивно разделяем массив на две половины до тех пор, пока не получим подмассивы из одного элемента
2. Затем сливаем отсортированные подмассивы в один отсортированный массив

**Сложность:**
- Временная: O(n log n) во всех случаях
- Пространственная: O(n) (требуется дополнительная память)

**Преимущества:**
- Стабильная сортировка
- Всегда работает за O(n log n)
- Хорошо подходит для внешней сортировки (когда данные не помещаются в оперативную память)

**Недостатки:**
- Требует дополнительной памяти O(n)
- На небольших массивах менее эффективна, чем сортировка вставками

**Реализация на C++:**
```cpp
void merge(vector<int>& arr, int l, int m, int r) {
    vector<int> left(arr.begin() + l, arr.begin() + m + 1);
    vector<int> right(arr.begin() + m + 1, arr.begin() + r + 1);
    
    int i = 0, j = 0, k = l;
    while (i < left.size() && j < right.size()) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }
    
    while (i < left.size()) arr[k++] = left[i++];
    while (j < right.size()) arr[k++] = right[j++];
}

void mergeSort(vector<int>& arr, int l, int r) {
    if (l >= r) return;
    int m = l + (r - l) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);
}
```

## 2) Quick Sort (Быстрая сортировка) и K-ая порядковая статистика

> Быстрый метод сортировки функционирует по принципу "разделяй и властвуй".

>Массив `a[l…r]` разбивается на два (возможно пустых) подмассива `a[l…q]` и `a[q+1…r]`, таких, что каждый элемент `a[l…q]` меньше или равен `a[q]` , который в свою очередь, не превышает любой элемент подмассива `a[q+1…r]`. Индекс вычисляется в ходе процедуры разбиения. Подмассивы `a[l…q]` и `a[q+1…r]` сортируются с помощью рекурсивного вызова процедуры быстрой сортировки. Поскольку подмассивы сортируются на месте, для их объединения не требуются никакие действия: весь массив `a[l…r]` оказывается отсортированным.

**Принцип работы Quick Sort:**
1. Выбираем опорный элемент (pivot)
2. Разделяем массив на две части: элементы меньше pivot и элементы больше pivot
3. Рекурсивно применяем алгоритм к обеим частям

**Сложность:**
- Средний случай: O(n log n)
- Худший случай: O(n²) (при неудачном выборе pivot)
- Пространственная: O(log n) (из-за рекурсии)

**K-ая порядковая статистика:**
- Это элемент, который окажется на k-й позиции в отсортированном массиве
- Можно найти за O(n) в среднем случае с помощью модификации QuickSort (QuickSelect)

**Реализация QuickSort:**
```cpp
int partition(vector<int>& arr, int l, int r) {
    int pivot = arr[r];
    int i = l;
    for (int j = l; j < r; j++) {
        if (arr[j] < pivot) {
            swap(arr[i], arr[j]);
            i++;
        }
    }
    swap(arr[i], arr[r]);
    return i;
}

void quickSort(vector<int>& arr, int l, int r) {
    if (l >= r) return;
    int p = partition(arr, l, r);
    quickSort(arr, l, p - 1);
    quickSort(arr, p + 1, r);
}
```

**Реализация QuickSelect (нахождение k-й порядковой статистики):**
```cpp
int quickSelect(vector<int>& arr, int l, int r, int k) {
    if (l == r) return arr[l];
    int p = partition(arr, l, r);
    if (k == p) return arr[p];
    else if (k < p) return quickSelect(arr, l, p - 1, k);
    else return quickSelect(arr, p + 1, r, k);
}
```

## 3) Heap Sort (Сортировка кучей) и очередь с приоритетом

> Для начла можно ознакомиться с Кучей [[Heap]]

> Сортировка кучей, пирамидальная сортировка (англ. Heapsort) — алгоритм сортировки, использующий структуру данных двоичная куча. Это неустойчивый алгоритм сортировки с временем работы O(nlogn), где n — количество элементов для сортировки, и использующий O(1) дополнительной памяти.

### Алгоритм работы

[Ссылка на источник. Спасибо Билалу](https://github.com/billyshmil059/algorithms/blob/main/Sorts.md#алгоритм-работы)

>Необходимо отсортировать массив A, размером n. Построим на базе этого массива за O(n) кучу для максимума. Так как максимальный элемент находится в корне, то если поменять его местами с `A[n−1]`, он встанет на своё место. Далее вызовем процедуру `siftDown(0)`, предварительно уменьшив `heapSize` на 1. Она за `O(logn)` просеет `A[0]` на нужное место и сформирует новую кучу (так как мы уменьшили её размер, то куча располагается с `A[0]` по `A[n−2]`, а элемент `A[n−1]` находится на своём месте). Повторим эту процедуру для новой кучи, только корень будет менять местами не с `A[n−1]`, а с `A[n−2]`. Делая аналогичные действия, пока `heapSize` не станет равен 1, мы будем ставить наибольшее из оставшихся чисел в конец не отсортированной части. Очевидно, что таким образом, мы получим отсортированный массив.


**Принцип работы Heap Sort:**
1. Построение max-heap из массива
2. Последовательное извлечение максимального элемента и перестроение кучи

**Сложность:**
- Временная: O(n log n) во всех случаях
- Пространственная: O(1) (сортировка на месте)

**Очередь с приоритетом:**
- Абстрактный тип данных, поддерживающий операции:
  - Вставка элемента
  - Извлечение элемента с максимальным (или минимальным) приоритетом
- Обычно реализуется на основе двоичной кучи

**Реализация HeapSort:**
```cpp
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    
    if (l < n && arr[l] > arr[largest]) largest = l;
    if (r < n && arr[r] > arr[largest]) largest = r;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();
    // Построение кучи (перегруппируем массив)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // Извлекаем элементы из кучи по одному
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

## 4) Теорема о скорости сортировки и устойчивость сортировки

**Теорема о скорости сортировки:**
- Любой алгоритм сортировки, основанный на сравнениях элементов, требует в худшем случае не менее Ω(n log n) сравнений.

**Следствия:**
- MergeSort, HeapSort, QuickSort (в среднем) оптимальны по скорости
- Сортировки, работающие быстрее O(n log n) (например, CountingSort), используют дополнительные предположения о данных

**Устойчивость сортировки:**
- Сортировка называется устойчивой, если она сохраняет относительный порядок равных элементов
- Устойчивые сортировки:
  - MergeSort
  - BubbleSort
  - InsertionSort
  - CountingSort
- Неустойчивые сортировки:
  - HeapSort
  - QuickSort (в стандартной реализации)
  - SelectionSort

## 5) Сортировка подсчётом и поразрядная сортировка
---
### Из файла Билала:
#### Сортировка подсчетом

>Пусть, например, нам гарантируется, что все числа натуральные и лежат в промежутке от 1 до 100. Тогда есть такой простой алгоритм:

- Создадим массив размера 100, в котором будем хранить на k-ом месте, сколько раз число k встретилось в этом массиве.
- Пройдемся по всем числам исходного массива и увеличим соответствующее значение массива на 1.
- После того, как мы посчитали, сколько раз каждое число встретилось, можно просто пройтись по этому массиву и вывести 1 столько раз, сколько встретилась 1, вывести 2 столько раз, сколько встретилась 2, и так далее.

>Время работы такого алгоритма составляет O(m+n), где m — число возможных значений, n — число элементов в массиве. Если количество возможных различных элементов в множестве относительно невелико, то сортировка подсчетом является одним из самых оптимальных решений.



#### Поразрядная сортировка

>Исходно предназначен для сортировки целых чисел, записанных цифрами. Но так как в памяти компьютеров любая информация записывается целыми числами, алгоритм пригоден для сортировки любых объектов, запись которых можно поделить на «разряды», содержащие сравнимые значения, например, строки, и вообще любые данные, представленные в виде набора байтов.

---

**Сортировка подсчётом:**
- Применяется, когда диапазон значений элементов (k) невелик по сравнению с количеством элементов (n)
- Сложность: O(n + k)
- Не основана на сравнениях
- Устойчивая

**Поразрядная сортировка (Radix Sort):**
- Сортирует числа поразрядно, начиная с младшего разряда
- Использует устойчивую сортировку (обычно CountingSort) для сортировки по каждому разряду
- Сложность: O(d(n + k)), где d - количество разрядов
- Применяется для сортировки чисел или строк

**Реализация CountingSort:**
```cpp
void countingSort(vector<int>& arr) {
    if (arr.empty()) return;
    
    int min_val = *min_element(arr.begin(), arr.end());
    int max_val = *max_element(arr.begin(), arr.end());
    int range = max_val - min_val + 1;
    
    vector<int> count(range), output(arr.size());
    
    for (int num : arr) count[num - min_val]++;
    for (int i = 1; i < range; i++) count[i] += count[i - 1];
    for (int i = arr.size() - 1; i >= 0; i--) {
        output[count[arr[i] - min_val] - 1] = arr[i];
        count[arr[i] - min_val]--;
    }
    
    arr = output;
}
```

**Реализация RadixSort:**
```cpp
void countingSortForRadix(vector<int>& arr, int exp) {
    vector<int> output(arr.size());
    vector<int> count(10, 0);
    
    for (int num : arr) count[(num / exp) % 10]++;
    for (int i = 1; i < 10; i++) count[i] += count[i - 1];
    for (int i = arr.size() - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    arr = output;
}

void radixSort(vector<int>& arr) {
    if (arr.empty()) return;
    
    int max_val = *max_element(arr.begin(), arr.end());
    for (int exp = 1; max_val / exp > 0; exp *= 10) {
        countingSortForRadix(arr, exp);
    }
}
```

## 6) Tim Sort
> Тут описана краткая информация о сортировке. Гораздо лучше описано у Билала, его конспект представлен по ссылке на самом верху, или же в частности про **Tim Sort** Чуть ниже
> 

**Особенности:**
- Гибридный алгоритм, сочетающий `MergeSort` и `InsertionSort`
- Разработан Тимом Петерсом в 2002 году для Python
- Стандартный алгоритм сортировки в Python, Java (для объектов), Android

**Принцип работы:**
1. Массив разбивается на подмассивы (runs)
2. Маленькие подмассивы сортируются `InsertionSort` (эффективен на небольших данных)
3. Отсортированные подмассивы сливаются с помощью модифицированного `MergeSort`

**Преимущества:**
- Эффективен на реальных данных (частично отсортированных)
- Устойчивая сортировка
- Хорошо использует кэш процессора

**Сложность:**
- В худшем случае: O(n log n)
- В лучшем случае (уже отсортированный массив): O(n)
- Пространственная: O(n)

**Оптимизации:**
- Минимальный размер run выбирается эмпирически (обычно 32-64)
- Использует бинарную вставку вместо линейного поиска в `InsertionSort`
- При слиянии учитывает уже упорядоченные участки

**Псевдокод:**
```cpp
function timSort(arr):
    minRun = calculateMinRun(length(arr))
    
    # Сортировка отдельных подмассивов
    for start from 0 to length(arr) by minRun:
        end = min(start + minRun - 1, length(arr) - 1)
        insertionSort(arr, start, end)
    
    # Слияние подмассивов
    size = minRun
    while size < length(arr):
        for left from 0 to length(arr) by 2*size:
            mid = min(left + size - 1, length(arr) - 1)
            right = min(left + 2*size - 1, length(arr) - 1)
            merge(arr, left, mid, right)
        size *= 2
```



## TimSort Билала



1. Поиск "минимайков" (minrun): Алгоритм разбивает массив на небольшие блоки (обычно от 32 до 64 элементов). Эти блоки ищутся как уже упорядоченные последовательности (возрастающие или убывающие). Убывающие последовательности переворачивают, чтобы они стали возрастающими. Пример: В массиве `[5, 3, 1, 2, 4, 7, 6]` найдутся блоки `[5, 3, 1]` (перевернётся в `[1, 3, 5]`), `[2, 4, 7]` и `[6]`.
    
2. Сортировка вставками для маленьких блоков: Каждый найденный блок сортируется вставками — этот метод эффективен на небольших и почти упорядоченных данных.
    
3. Слияние блоков: Отсортированные блоки объединяются попарно, как в сортировке слиянием. Но Timsort делает это умно:
    

- Следит, чтобы размеры сливаемых блоков были примерно одинаковыми (это уменьшает количество операций).
- Использует галоп-поиск для быстрого нахождения позиций элементов при слиянии.

**Почему Timsort такой эффективный?**

- Работает с частичной упорядоченностью: Если данные уже частично отсортированы, Timsort тратит меньше времени (почти линейное время O(n)).
- Устойчивость: Сохраняет порядок равных элементов (важно для сортировки по нескольким ключам).
- Баланс скорости и памяти: Худший случай — O(n log n), как у быстрой сортировки, но на реальных данных часто работает быстрее.
- Экономит память: Работает "на месте" (не требует выделения дополнительной памяти для всех элементов).

Пример кода:

```c
#include <iostream>
#include <vector>
#include <algorithm>

const int MIN_MERGE = 32;

// Находим минимальную длину подмассива (minrun)
int calcMinRun(int n) {
    int r = 0;
    while (n >= MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
    }
    return n + r;
}

// Сортировка вставками для подмассивов
void insertionSort(std::vector<int>& arr, int left, int right) {
    for (int i = left + 1; i <= right; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= left && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

// Слияние двух подмассивов
void merge(std::vector<int>& arr, int l, int m, int r) {
    int len1 = m - l + 1, len2 = r - m;
    std::vector<int> left(len1), right(len2);
    
    for (int i = 0; i < len1; i++)
        left[i] = arr[l + i];
    for (int i = 0; i < len2; i++)
        right[i] = arr[m + 1 + i];

    int i = 0, j = 0, k = l;
    
    while (i < len1 && j < len2) {
        if (left[i] <= right[j]) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }

    while (i < len1) {
        arr[k] = left[i];
        i++;
        k++;
    }

    while (j < len2) {
        arr[k] = right[j];
        j++;
        k++;
    }
}

// Основная функция Timsort
void timSort(std::vector<int>& arr) {
    int n = arr.size();
    if (n < 2) return;

    int minRun = calcMinRun(n);

    // Сортировка отдельных подмассивов
    for (int start = 0; start < n; start += minRun) {
        int end = std::min(start + minRun - 1, n - 1);
        insertionSort(arr, start, end);
    }

    // Слияние отсортированных подмассивов
    for (int size = minRun; size < n; size = 2 * size) {
        for (int left = 0; left < n; left += 2 * size) {
            int mid = left + size - 1;
            int right = std::min(left + 2 * size - 1, n - 1);
            if (mid < right) {
                merge(arr, left, mid, right);
            }
        }
    }
}
```