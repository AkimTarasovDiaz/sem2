# Темы:
1. Обход дерева в ширину
2. Обход в глубину
3. Декартово дерево
4. АВЛ дерево
5. Красно-чёрное дерево
6. Splay дерево

---

# **Подробный разбор алгоритмов и структур данных**

## **1. Обход дерева в ширину (BFS)**

### **Полное описание**
BFS — метод обхода графов и деревьев, исследующий все вершины на текущей глубине перед переходом на следующий уровень.

### **Детали реализации**
- **Используемая структура**: очередь (FIFO)
- **Шаги алгоритма**:
  1. Поместить корневую вершину в очередь.
  2. Пока очередь не пуста:
     a. Извлечь вершину из начала очереди.
     b. Обработать вершину.
     c. Добавить всех непосещённых соседей в конец очереди.
  3. Помечать посещённые вершины для избежания циклов (в графах).

### **Псевдокод**
```
BFS(Graph, start_vertex):
    queue = new Queue()
    visited = new Set()
    queue.enqueue(start_vertex)
    visited.add(start_vertex)
    
    while not queue.empty():
        current = queue.dequeue()
        process(current)
        for neighbor in Graph.adjacent(current):
            if neighbor not in visited:
                visited.add(neighbor)
                queue.enqueue(neighbor)
```

### **Особенности**
- Гарантированно находит кратчайший путь в невзвешенных графах
- Требует O(n) памяти для хранения очереди
- Не рекурсивный (итеративный подход)

### **Визуализация обхода**
```
       A
     /   \
    B     C
   / \   / \
  D   E F   G

Порядок обхода: A → B → C → D → E → F → G
```

## **2. Обход дерева в глубину (DFS)**

### **Полное описание**
DFS — алгоритм, исследующий ветви дерева до самого конца перед переходом к соседним ветвям.

### **Варианты обхода**
1. **Pre-order** (прямой):
   - Посещаем корень
   - Рекурсивно левое поддерево
   - Рекурсивно правое поддерево
   - Применение: копирование дерева

2. **In-order** (симметричный):
   - Рекурсивно левое поддерево
   - Посещаем корень
   - Рекурсивно правое поддерево
   - Применение: получение отсортированного порядка в BST

3. **Post-order** (обратный):
   - Рекурсивно левое поддерево
   - Рекурсивно правое поддерево
   - Посещаем корень
   - Применение: удаление дерева

### **Рекурсивная реализация (Pre-order)**
```cpp
void dfsPreOrder(Node* node) {
    if (!node) return;
    cout << node->value << " "; // Обработка
    dfsPreOrder(node->left);
    dfsPreOrder(node->right);
}
```

### **Итеративная реализация (стековая)**
```cpp
void dfsIterative(Node* root) {
    stack<Node*> s;
    s.push(root);
    while (!s.empty()) {
        Node* current = s.top();
        s.pop();
        cout << current->value << " ";
        if (current->right) s.push(current->right);
        if (current->left) s.push(current->left);
    }
}
```
# **Визуализация обходов дерева: Pre-order, In-order, Post-order**

Рассмотрим бинарное дерево:
```
        A
       / \
      B   C
     / \   \
    D   E   F
```

## **1. Pre-order (Прямой обход)**
**Порядок:** Корень → Левое поддерево → Правое поддерево  
**Применение:** Копирование структуры дерева, префиксная запись выражений

### **Пошаговое выполнение:**
1. Посещаем **A** (корень)
2. Переходим к левому поддереву (**B**)
   - Посещаем **B**
   - Идем влево к **D**
     - Посещаем **D**
   - Идем вправо к **E**
     - Посещаем **E**
3. Возвращаемся к правому поддереву **A** (**C**)
   - Посещаем **C**
   - Идем вправо к **F**
     - Посещаем **F**

**Результат:** `A → B → D → E → C → F`

### **Визуализация:**
```
Шаг 1: [A]
Шаг 2: [A, B]
Шаг 3: [A, B, D]
Шаг 4: [A, B, D, E]
Шаг 5: [A, B, D, E, C]
Шаг 6: [A, B, D, E, C, F]
```

## **2. In-order (Симметричный обход)**
**Порядок:** Левое поддерево → Корень → Правое поддерево  
**Применение:** Получение отсортированных данных в BST, инфиксная запись выражений

### **Пошаговое выполнение:**
1. Начинаем с **A**, но сначала идем влево:
   - Достигаем **B**, снова идем влево:
     - Посещаем **D** (левый лист)
   - Возвращаемся к **B** и посещаем его
   - Идем вправо к **E** и посещаем его
2. Возвращаемся к **A** и посещаем его
3. Идем вправо к **C**:
   - У **C** нет левого поддерева, посещаем **C**
   - Идем вправо к **F** и посещаем его

**Результат:** `D → B → E → A → C → F`

### **Визуализация:**
```
Шаг 1: [D]
Шаг 2: [D, B]
Шаг 3: [D, B, E]
Шаг 4: [D, B, E, A]
Шаг 5: [D, B, E, A, C]
Шаг 6: [D, B, E, A, C, F]
```

## **3. Post-order (Обратный обход)**
**Порядок:** Левое поддерево → Правое поддерево → Корень  
**Применение:** Удаление дерева, постфиксная запись выражений

### **Пошаговое выполнение:**
1. Начинаем с **A**, но сначала идем влево:
   - Достигаем **B**, снова идем влево:
     - Посещаем **D** (левый лист)
   - Возвращаемся к **B**, идем вправо:
     - Посещаем **E**
   - Теперь посещаем **B**
2. Возвращаемся к **A**, идем вправо:
   - Достигаем **C**, идем вправо:
     - Посещаем **F**
   - Посещаем **C**
3. Наконец посещаем **A**

**Результат:** `D → E → B → F → C → A`

### **Визуализация:**
```
Шаг 1: [D]
Шаг 2: [D, E]
Шаг 3: [D, E, B]
Шаг 4: [D, E, B, F]
Шаг 5: [D, E, B, F, C]
Шаг 6: [D, E, B, F, C, A]
```

## **Сравнение обходов**
| Тип обхода | Порядок | Результат для примера | Основное применение |
|------------|---------|-----------------------|---------------------|
| **Pre-order** | Корень → Лево → Право | A → B → D → E → C → F | Клонирование деревьев, сериализация |
| **In-order** | Лево → Корень → Право | D → B → E → A → C → F | Получение отсортированных данных (в BST) |
| **Post-order** | Лево → Право → Корень | D → E → B → F → C → A | Удаление дерева, обратные вычисления |

## **Графическая иллюстрация**
```
Pre-order:    A → B → D → E → C → F
            /   / \     \
          A   B   C     F
            / \   \
           D   E   F

In-order:    D → B → E → A → C → F
              /   / \     \
            D   B   A     C
                \     \
                 E     F

Post-order:  D → E → B → F → C → A
              \   /     /   /
               E B     F C
                 \     /
                  B   C
                    \ /
                     A
```

Все три обхода являются **глубинными (DFS)** и используют стек (явный или неявный в рекурсии) для обработки узлов. Выбор обхода зависит от конкретной задачи.
### **Сравнение с BFS**
| Характеристика | BFS | DFS |
|---------------|-----|-----|
| Структура данных | Очередь | Стек |
| Память | O(n) | O(h) |
| Кратчайший путь | Да (невзв. графы) | Нет |
| Рекурсия | Нет | Да/Нет |

## **3. Декартово дерево (Treap)**

### **Полное описание**
Структура данных, сочетающая:
1. Бинарное дерево поиска (по ключам)
2. Кучу (по приоритетам)

### **Операции и их реализация**

**Вставка:**
1. Вставляем по ключу как в BST
2. Восстанавливаем свойства кучи с помощью поворотов

```cpp
Node* insert(Node* root, int key) {
    if (!root) return new Node(key);
    
    if (key < root->key) {
        root->left = insert(root->left, key);
        if (root->left->priority > root->priority)
            root = rightRotate(root);
    } else {
        root->right = insert(root->right, key);
        if (root->right->priority > root->priority)
            root = leftRotate(root);
    }
    return root;
}
```

**Удаление:**
1. Находим узел
2. Если это лист — удаляем
3. Иначе:
   - Поворачиваем с ребёнком с большим приоритетом
   - Рекурсивно удаляем в поддереве

### **Теоретическая основа**
- Ожидаемая высота: O(log n) при случайных приоритетах
- Операции: O(log n) в среднем

### **Применение**
- Реализация персистентных структур
- Решение задач на отрезки

## **4. АВЛ-дерево**

### **Полное описание**
Самобалансирующееся BST, где для каждого узла:
| высота(left) - высота(right) | ≤ 1

### **Балансировка**
**4 типа нарушений:**
1. Left-Left (LL) — правый поворот
2. Right-Right (RR) — левый поворот
3. Left-Right (LR) — левый + правый
4. Right-Left (RL) — правый + левый

**Формула баланс-фактора:**
```
balance = height(left) - height(right)
```

### **Пример кода (повороты)**
```cpp
Node* rightRotate(Node* y) {
    Node* x = y->left;
    y->left = x->right;
    x->right = y;
    updateHeight(y);
    updateHeight(x);
    return x;
}
```

### **Сложность операций**
- Вставка: O(log n) (максимум 2 поворота)
- Удаление: O(log n) (до O(log n) поворотов)
- Поиск: O(log n)

## **5. Красно-чёрное дерево**

### **Полные свойства**
1. Каждый узел — красный или чёрный
2. Корень всегда чёрный
3. Листья (NIL) чёрные
4. У красного узла оба ребёнка чёрные
5. Все пути от узла к листьям содержат одинаковое количество чёрных узлов

### **Балансировка при вставке**
**3 случая:**
1. Дядя красный — перекрашивание
2. Дядя чёрный (треугольник) — поворот
3. Дядя чёрный (линия) — поворот + перекрашивание

### **Пример кода (вставка)**
```cpp
void insertFixup(Node* z) {
    while (z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            Node* y = z->parent->parent->right;
            if (y->color == RED) { // Случай 1
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) { // Случай 2
                    z = z->parent;
                    leftRotate(z);
                }
                // Случай 3
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rightRotate(z->parent->parent);
            }
        }
        // Зеркальный случай...
    }
    root->color = BLACK;
}
```

## **6. Splay-дерево**

### **Полное описание**
Самокорректирующееся дерево, где:
- Недавно доступные элементы перемещаются ближе к корню
- Не гарантирует сбалансированность
- Амортизированное время O(log n)

### **Операция Splay**
**3 вида splay-шагов:**
1. Zig (одиночный поворот)
2. Zig-zig (двойной поворот)
3. Zig-zag (зигзагообразный поворот)

### **Пример кода**
```cpp
Node* splay(Node* root, int key) {
    if (!root || root->key == key) return root;
    
    if (key < root->key) {
        // Ключ в левом поддереве...
        if (!root->left) return root;
        
        // Zig-zig (лево-лево)
        if (key < root->left->key) {
            root->left->left = splay(root->left->left, key);
            root = rightRotate(root);
        }
        // Zig-zag (лево-право)
        else if (key > root->left->key) {
            root->left->right = splay(root->left->right, key);
            if (root->left->right)
                root->left = leftRotate(root->left);
        }
        return (root->left) ? rightRotate(root) : root;
    }
    // Зеркальный случай для правого поддерева...
}
```

### **Применение**
- Кэширование
- Алгоритмы с локальностью обращений
- Реализация LRU-кэшей

## **Сравнение сбалансированных деревьев**
| Параметр | AVL | Красно-чёрное | Splay |
|----------|-----|--------------|-------|
| Балансировка | Строгая | Умеренная | Динамическая |
| Вставка | O(log n) | O(log n) | O(log n) амортиз. |
| Поиск | O(log n) | O(log n) | O(log n) амортиз. |
| Удаление | O(log n) | O(log n) | O(log n) амортиз. |
| Память | O(n) | O(n) | O(n) |
| Применение | Частые поиски | Универсальное | Частые доступы |
