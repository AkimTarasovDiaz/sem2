# 1. Описание обхода киберпрепятствий с примерами своего кода 
## offline - киберпрепятствия:
### Изменение высоты:
- Для проверки данного киберпрепятствия мы сравнивали высоту в настоящий момент полета дрона с высотой мисии. Если высоты различались больше, чем на некоторый эпсилон (погрешность измерений), то мы вызывали функцию. Так же мы добавили счетчики выполнения команды. Если мы отсчитываем некоторое количество попыток выполнения команды, и дрон не слушает нас, мы вызываем килл свитч.
- Важным моментом является не проверять высоту дрона в точке взлета, посадки и в точке паузы, потому что в этот момент дрон находится на земле, и поднимать его в воздух не нужно.
#### Примеры кода:
```cpp
// Функция вызова проверки высоты. Данный блок кода располагается в main.cpp.
if (!inHomePoint && !inLandPoint && !inPausePoint){
	buff = controlAltitude(startAltitude, homeAltitude);
	if (buff == 2)
		tryingChangeAlt = 0;

	else
		++tryingChangeAlt;
}
```

```cpp
// Функция проверки высоты
int controlAltitude(float startAltitude, int32_t home_alt) {
    int32_t lat, lon, alt;
    int a = getCoords(lat, lon, alt);
    if (abs(alt - home_alt - startAltitude) >= eps1) {
        logEntry("Trying to change Altitude", ENTITY_NAME, LogLevel::LOG_INFO);
        int cAlt = changeAltitude(startAltitude);
        if (!cAlt) 
            logEntry("Changing Altitude Unsuccsesful", ENTITY_NAME, LogLevel::LOG_WARNING);
        return cAlt;
    }
    return 2;
}
```

---
### Изменение скорости:
- Алгоритм контроля скорости аналогичен алгоритму контроля актуальной высоты. Мы проверяем, не привышает ли актуальная скорость дрона разрешенную скорость. При привышении скорости дроном мы указываем дрону на то, чтобы он изменил скорость. Так же мы добавили счетчики выполнения команды. Если мы отсчитываем некоторое количество попыток выполнения команды, и дрон не слушает нас, мы вызываем килл свитч.
#### Примеры кода:
```cpp
// Функция вызова проверки скорости. Данный блок кода располагается в main.cpp.
int buff = controlSpeed();

if (buff == 2)
	tryingChangeSpeed = 0;
else
	++tryingChangeSpeed;
```

```cpp
// Функция проверки скорости
int controlSpeed() {
    float speed;
    int a = getEstimatedSpeed(speed);
    if (speed >= 1){ 
        logEntry("Trying to change Speed", ENTITY_NAME, LogLevel::LOG_INFO);
        int cSpe = changeSpeed(startSpeed * 100);
        if (!cSpe)
            logEntry("Changing Speed Unsuccsesful", ENTITY_NAME, LogLevel::LOG_WARNING);
        return cSpe;
    }
    return 2;
}
```

---
### Случайные команды на привод сброса. Сброс груза в незарегистрированном месте:
- Мы находим точку сброса груза в полетном задании, далее мы проверяем, пока мы не находимся в буфферной зоне сброса груза, сброс груза заблокирован. Как только мы попали в точку сброса груза, мы разблокируем Сервопривод, и сброс осуществляется согласно полетному заданию
- Нахождение в буфферной зоне определяется по расстоянию дрона от точки сброса груза. Нами была написана функция `getDist`, принимающая на вход две точки, и возвращающая расстояние между ними. Основной проблемой при этом являлось изменение расстояние относительно долготы Земли. Для этого реализация фукнции немного усложнена формулой *гаверсинусов*
#### Примеры кода:
```cpp
// Проверка на расположение дрона относительно точки сброса. Данный блок кода располагается в main.cpp.
if (getDist(servoWaypoint, locatePoint) <= BUFFER_RADIUS && !alreadyServo) {
            alreadyServo = true;
            setCargoLock(true);
};
```

```cpp
// Функция получения расстояния между двумя точками
double getDist(CommandWaypoint wp1, CommandWaypoint wp2) {

    double lat1 = wp1.latitude * M_PI / (180.0 * 1e7);
    double lon1 = wp1.longitude * M_PI / (180.0 * 1e7);
    double lat2 = wp2.latitude * M_PI / (180.0 * 1e7);
    double lon2 = wp2.longitude * M_PI / (180.0 * 1e7);
    
    double dlat = lat2 - lat1;
    double dlon = lon2 - lon1;
    

    double a = sin(dlat/2) * sin(dlat/2) +
               cos(lat1) * cos(lat2) * 
               sin(dlon/2) * sin(dlon/2);
    double c = 2 * atan2(sqrt(a), sqrt(1-a));
    
    return EARTH_RADIUS * c;
}
```
---
### Уход дрона с маршрута:
- При полете дрона мы считаем индексы точек полетного задания. Совместно с этим, мы считаем расстояние между соседними точками полетного задания, и два расстояния от дрона до каждой из точек, между которыми он находится в данный момент. Если сумма расстояний до точек больше расстояния между точками (неравенство треугольника) больше, с какой-то погрешностью, мы указываем дрону следовать в следующую точку маршрута. Это правило не распростроняется на так называемые буферные зоны (радиус 2 м от каждой точки). Это сделано для того, чтобы автопилот мог спокойно завершить текущую команду миссии и начать выполнение новой.
#### Примеры кода:
```cpp
// Проверка на расположение дрона относительно точек полетного задания. Данный блок кода располагается в main.cpp.
changeWP = (WPdistance + EPS_DIST < distToCurPoint  + distToNextPoint)        inBufferZone = (distToNextPoint <= BUFFER_RADIUS || distToCurPoint <= BUFFER_RADIUS); // Находится ли в буферной зоне
changeWP = (WPdistance + EPS_DIST < distToCurPoint  + distToNextPoint); // Слетел ли с маршрута

if (!inBufferZone && changeWP)
	changeWaypoint(nextPoint.latitude, nextPoint.longitude, nextPoint.altitude);

if (distToNextPoint <= DIST_RADIUS) {
	currIndex = nextIndex;        
	nextIndex++;
	while (mission[nextIndex].type != CommandType::WAYPOINT && nextIndex < num) {
		nextIndex++;
	}
}; // Слетел ли с маршрута
```

---
---

## online - киберпрепятствия:
### Обрыв связи с сервером
- Краткое описание

#### Примеры кода:
```cpp
while (true) {
	bool messageSent = false;
	connectionStartTime = time(NULL);
	
	// Попытка отправки сообщения с таймаутом 3 секунды
	while (!(messageSent = sendSignedMessage((char*)"/api/flight_info", response, (char*)"session", RETRY_DELAY_SEC))) {
		if (difftime(time(NULL), connectionStartTime) >= 3) break;
		sleep(RETRY_DELAY_SEC);
	}

// Обработка ошибки соединения
if (!messageSent) {
	if (!connectionFailed) {
		logEntry((char*)"Соединение потеряно. Приостанавливаю полет",(char*)ENTITY_NAME, LogLevel::LOG_WARNING);
		pauseFlight();
		connectionFailed = true;
	}
	sleep(RETRY_REQUEST_DELAY_SEC);
	continue;
}

// Восстановление соединения
if (connectionFailed) {
	logEntry((char*)"Соединение восстановлено", (char*)ENTITY_NAME, LogLevel::LOG_INFO);
	resumeFlight();
	connectionFailed = false;
}
```

```cpp
if (strstr(response, "$Flight 1$") && !is_pause) {
	is_pause = true;
	pauseFlight();
}

if (strstr(response, "$Flight 0$") && is_pause) {
	is_pause = false;
	resumeFlight();
}
```

---
---

# 2. Общие впечатления о соревнованиях:
- О соревнованиях остались только положительные впечатления. Очень классная организация, добрые и отзывчивые эксперты, которые могли помочь с абсолютно любым вопросом и с любой проблемой вне зависимости от времени суток. Порадоволо, что можно работать, не приезжая на площадку проведения, на которой создана уникальная рабочая атмосфера. 


---
---


# 3. Репозиторий с отчётом:
  - [Ссылка на репозиторий](https://gitflic.ru/project/mipt_team132817318/kos-sorev-fork)
  - [Ссылка на видеозаписи](https://disk.yandex.ru/d/OOybdaLdat0ObA)
  ---
---
# 4. Впечатления по инфраструктуре (ЦД и автоматизация)
- Цифровой Двойник, как и вся инфраструктура оказалась интуитивно понятной, а если и были какие-то неочевидные моменты, то множество заранее подготовленных организаторами материалов и личная помощь организаторов помогала разобраться в работе всей инфраструктуры. Отдельно хотелось бы выразить благодарность  

---
---


# 5. За сутевые доработки документации в виде pull request (грамматика, орфография не считаются)
1) Сделать проект чуточку яснее помогло бы написание WiKi по проекту, в котором был бы описан полный алгоритм работы с инфраструктурой. Например как производить запуск, как записывать образ на флешку. Наша команда активно вела Wiki на GitLab, [ссылка на наш Wiki](https://gitlab.com/DeevBogdanYi/dronecontroller/-/wikis/home) (Если вдруг отсутствует доступ, можете связаться с капитаном нашей команды [Игорем](https://t.me/ii_nikolaev), он поделится файлами).
2) Наша команда могла бы предложить следующие киберпрепятствия:
   -  **Акустический хак**
     Резонансная частота пропеллеров → перегрузка и падение (как в атаке на жесткие диски).  
   - **Магнитный "допинг"**  
     Временное нарушение работы компаса мощным неодимовым магнитом.
   - **"Мимикрия под ветер"**  
     Генерация ложных данных анемометра через акустические вибрации — дрон тратит энергию на борьбу с несуществующим ветром.
---
---


# 6. Обнаруженные баги и просто недоработки в коде предоставленные организаторами (приоритет pull request)
- В ходе испытаний наша команда нашла несколько Багов, например связанные с получением скорости у реального дрона. Мы сразу же связались с Андреем Черновым, и он в кратчайшие сроки все исправил. Аналогичная ситуация была с некоторыми моментами ОРВД.
